# A playground

# Arguments passed to gen.sh; used when regenerating this file.
gen_args =
target_type = bin

common_dir = ..

include $common_dir/common.ninja

name = main
mode = üêã $

# between common_dir and the current directory, take the one that's higher up
# and renormalize against that?
#
# the highest path get's mapped to /opt/
# the lower ones can be placed in subdirectories of /opt/
#
# we can then go assign common_dir to be a relative path so that things work
# inside and outside the container
#
#
# For example: common_dir = /tmp/foo/bar/baz/common; proj = /tmp/foo/thing;
# proj is higher so it gets mounted to /opt/thing/
# common_dir gets mounted to /opt/foo/bar/baz/common
#
# Here's another take:
# The relative path to common_dir from proj_dir on the host must be the same
# as the relative path to common_dir from the working directory in the
# container in order for ninja and the commands run in the container to work.
#
# So, let's get the relative path of the common_dir to proj_dir:
common_dir = $$(realpath --relative-to=. $common_dir)
# If common_dir is inside proj_dir this will be of the form `foo/bar/baz/`;
# else it'll have `..`'s in it.
#
# For the first case (common_dir is in us - or _is_ us) we can mount proj_dir
# in /opt/ and keep common_dir as is. Nice and easy.
#
# For the second case (common_dir is not in us) we'll have to find the point
# as which the two paths diverge (i.e. in the above it's at /tmp/foo) and
# treat that as /opt/. Then we have to mount common_dir and proj_dir relative
# to /opt/ the way they're relative to the point they diverge at. Finally, if
# we set the working dir for the container to proj_dir's mount point, things
# should work.
#
# Note that the approach described for the second case _handles_ the first
# case.
#
# This generalizes well for modules (multiple paths) too. Find the common
# prefix path, rewrite all paths as relative paths, map the common prefix as
# /opt/ (our 'root') and then set the working directory to the project's path.



docker_prefix = docker run
docker_flags  = -v $$(realpath .):/opt/ -v $$(realpath $common_dir):/opt/.. -t
docker_cntnr  = rrbutani/arm-llvm-toolchain

# common_dir = /opt/common

cc_opt_level  = $cc_opt_debug
lto_opt_level = $lto_opt_debug

build $builddir/debug/objs/startup.o: cc ${common_dir}/src/startup.c
build $builddir/debug/objs/intrinsics.o: as ${common_dir}/asm/intrinsics.s
build $builddir/debug/objs/main.o: cxx main.cpp

build $builddir/debug/$name.out: link $
  $builddir/debug/objs/startup.o $
  $builddir/debug/objs/main.o $
  $builddir/debug/objs/intrinsics.o

build $builddir/debug/$name.axf: objcopy $builddir/debug/$name.out

build size: size $builddir/debug/$name.out
build build: phony $builddir/debug/$name.axf

build flash: flash $builddir/debug/$name.axf
    docker_flags = $docker_flags --privileged
build run: start $builddir/debug/$name.axf | flash
    docker_flags = $docker_flags --privileged

cc_opt_level  = $cc_opt_release
lto_opt_level = $lto_opt_release

build $builddir/release/objs/startup.o: cc ${common_dir}/src/startup.c
build $builddir/release/objs/intrinsics.o: as ${common_dir}/asm/intrinsics.s
build $builddir/release/objs/main.o: cxx main.cpp


build $builddir/release/$name.out: link $
  $builddir/release/objs/startup.o $
  $builddir/release/objs/main.o $
  $builddir/release/objs/intrinsics.o

build $builddir/release/$name.axf: objcopy $builddir/release/$name.out

build size-release: size $builddir/release/$name.out
build build-release: phony $builddir/release/$name.axf

build flash-release: flash $builddir/release/$name.axf
    docker_flags = $docker_flags --privileged
build run-release: start $builddir/release/$name.axf | flash-release
    docker_flags = $docker_flags --privileged

build clean: rm $builddir

build graph.png: graph
  ninja_graph_target = all
build graph: phony graph.png

default build

# TODO: should never be run in docker by us
# Or at least warn about this in the readme
build browse: browse
    ninja_browse_flags = -p 8000 -a 0.0.0.0
    docker_flags = $docker_flags -i -p 8000:8000

# TODO: This _must_ not run in docker (unless ninja is running in docker)
# actually this depends how clangd works..
build compile_commands.json: compdb
build compdb: phony compile_commands.json

# TODO: Only c/cpp files; clang-format will eat asm
build format: format src/startup.c src/main.c

build all: phony build-release build
